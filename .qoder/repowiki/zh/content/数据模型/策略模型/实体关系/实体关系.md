# 实体关系

<cite>
**本文档引用的文件**   
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [test_base.py](file://bkmonitor/bkmonitor/strategy/tests/test_base.py)
- [v2.py](file://packages/monitor_web/strategies/resources/v2.py)
- [public.py](file://packages/monitor_web/strategies/resources/public.py)
- [new_strategy.py](file://bkmonitor/bkmonitor/strategy/new_strategy.py)
- [strategy_label.py](file://packages/monitor_web/strategies/resources/strategy_label.py)
- [query_config.py](file://bkmonitor/bkmonitor/strategy/query_config.py)
- [action.py](file://bkmonitor/bkmonitor/action/serializers/strategy.py)
</cite>

## 目录
1. [引言](#引言)
2. [策略模型核心实体](#策略模型核心实体)
3. [策略与指标的关系](#策略与指标的关系)
4. [策略与数据源的关系](#策略与数据源的关系)
5. [策略与用户组的关系](#策略与用户组的关系)
6. [策略与服务拓扑的关系](#策略与服务拓扑的关系)
7. [策略标签系统与跨业务共享](#策略标签系统与跨业务共享)
8. [外键约束与级联操作](#外键约束与级联操作)
9. [实体关系图](#实体关系图)

## 引言
本文档深入分析监控系统中策略模型与其他核心实体的关系，包括与指标、数据源、用户组、服务拓扑的关联方式。通过详细分析代码结构和数据模型，揭示了策略ID如何关联到具体的监控数据源和采集配置，以及如何实现跨业务的策略共享和复用机制。文档还解释了外键约束和级联操作的具体实现方式。

## 策略模型核心实体
策略模型是监控系统的核心，它定义了监控规则、告警条件和响应动作。策略模型通过多个关联模型来实现复杂的监控逻辑。

```mermaid
erDiagram
STRATEGY {
int id PK
string name
string scenario
boolean is_enabled
int bk_biz_id
datetime create_time
datetime update_time
}
ITEM {
int id PK
int strategy_id FK
string expression
string name
}
QUERY_CONFIG {
int id PK
int item_id FK
string data_source_label
string data_type_label
string metric_id
json config
}
ALGORITHM {
int id PK
int item_id FK
int level
string algorithm_type
json config
}
DETECT {
int id PK
int strategy_id FK
int level
json config
}
ACTION_RELATION {
int id PK
int strategy_id FK
int config_id
json user_groups
json signal
}
STRATEGY_LABEL {
int id PK
string label_name
int strategy_id FK
int bk_biz_id
}
USER_GROUP {
int id PK
string name
int bk_biz_id
json channels
string timezone
}
DUTY_RULE {
int id PK
int user_group_id FK
string name
json config
}
DUTY_ARRANGE {
int id PK
int duty_rule_id FK
json users
json backups
}
STRATEGY ||--o{ ITEM : "包含"
ITEM ||--o{ QUERY_CONFIG : "包含"
ITEM ||--o{ ALGORITHM : "包含"
STRATEGY ||--o{ DETECT : "包含"
STRATEGY ||--o{ ACTION_RELATION : "关联"
STRATEGY ||--o{ STRATEGY_LABEL : "标记"
ACTION_RELATION }|--|| USER_GROUP : "通知"
USER_GROUP ||--o{ DUTY_RULE : "拥有"
DUTY_RULE ||--o{ DUTY_ARRANGE : "包含"
```

**图示来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)

**本节来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)

## 策略与指标的关系
策略通过指标配置来定义监控的具体内容。每个策略包含一个或多个监控项（Item），每个监控项又包含一个或多个查询配置（QueryConfig）和算法配置（Algorithm）。

```mermaid
classDiagram
class Strategy {
+int id
+string name
+int bk_biz_id
+bool is_enabled
+create_strategy()
+update_strategy()
+delete_strategy()
}
class Item {
+int id
+int strategy_id
+string expression
+string name
+save_items()
}
class QueryConfig {
+int id
+int item_id
+string data_source_label
+string data_type_label
+string metric_id
+json config
+save_query_config()
}
class Algorithm {
+int id
+int item_id
+int level
+string algorithm_type
+json config
+save_algorithms()
}
Strategy --> Item : "1对多"
Item --> QueryConfig : "1对多"
Item --> Algorithm : "1对多"
```

**图示来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [new_strategy.py](file://bkmonitor/bkmonitor/strategy/new_strategy.py)

**本节来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [new_strategy.py](file://bkmonitor/bkmonitor/strategy/new_strategy.py)

## 策略与数据源的关系
策略通过查询配置模型与具体的数据源建立关联。数据源标签（data_source_label）和数据类型标签（data_type_label）用于标识数据来源。

```mermaid
flowchart TD
Strategy[策略] --> Item[监控项]
Item --> QueryConfig[查询配置]
QueryConfig --> DataSource[数据源]
subgraph 数据源类型
BKMonitor[BK监控采集器]
Custom[自定义上报]
GSE[GSE数据]
Prometheus[Prometheus]
LogSearch[日志检索]
end
QueryConfig --> |data_source_label| BKMonitor
QueryConfig --> |data_source_label| Custom
QueryConfig --> |data_source_label| GSE
QueryConfig --> |data_source_label| Prometheus
QueryConfig --> |data_source_label| LogSearch
subgraph 数据类型
TimeSeries[时序数据]
Event[事件数据]
Log[日志数据]
Alert[告警数据]
end
QueryConfig --> |data_type_label| TimeSeries
QueryConfig --> |data_type_label| Event
QueryConfig --> |data_type_label| Log
QueryConfig --> |data_type_label| Alert
```

**图示来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [query_config.py](file://bkmonitor/bkmonitor/strategy/query_config.py)

**本节来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [query_config.py](file://bkmonitor/bkmonitor/strategy/query_config.py)

## 策略与用户组的关系
策略通过动作配置关系模型与用户组建立关联，实现告警通知的分发。用户组还包含轮值规则，用于定义值班安排。

```mermaid
classDiagram
class Strategy {
+int id
+string name
}
class ActionRelation {
+int id
+int strategy_id
+int config_id
+json user_groups
+json signal
}
class UserGroup {
+int id
+string name
+int bk_biz_id
+json channels
+string timezone
+bool need_duty
}
class DutyRule {
+int id
+int user_group_id
+string name
+json config
+json work_times
}
class DutyArrange {
+int id
+int duty_rule_id
+json users
+json backups
+json exclude_settings
}
class DutyPlan {
+int id
+int user_group_id
+int duty_rule_id
+int duty_arrange_id
+string start_time
+string finished_time
+json users
+json work_times
+string timezone
}
Strategy --> ActionRelation : "关联"
ActionRelation --> UserGroup : "通知"
UserGroup --> DutyRule : "拥有"
DutyRule --> DutyArrange : "包含"
DutyRule --> DutyPlan : "生成"
```

**图示来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [action.py](file://bkmonitor/bkmonitor/action/serializers/strategy.py)

**本节来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [action.py](file://bkmonitor/bkmonitor/action/serializers/strategy.py)

## 策略与服务拓扑的关系
策略通过目标（target）配置与服务拓扑建立关联。服务拓扑信息用于确定监控范围和告警上下文。

```mermaid
sequenceDiagram
participant Strategy as 策略
participant TopoNodeFuller as 拓扑节点填充器
participant HostManager as 主机管理器
participant ServiceInstanceManager as 服务实例管理器
Strategy->>TopoNodeFuller : full(record)
TopoNodeFuller->>HostManager : get(host_id)
HostManager-->>TopoNodeFuller : 返回主机拓扑链
TopoNodeFuller->>ServiceInstanceManager : get(service_instance_id)
ServiceInstanceManager-->>TopoNodeFuller : 返回服务实例拓扑链
TopoNodeFuller->>Strategy : 添加bk_topo_node维度
Strategy->>Strategy : 更新告警记录的维度信息
```

**图示来源**
- [test_fullers.py](file://alarm_backends/tests/service/access/data/test_fullers.py)

**本节来源**
- [test_fullers.py](file://alarm_backends/tests/service/access/data/test_fullers.py)

## 策略标签系统与跨业务共享
策略标签系统实现了策略的分类管理和跨业务共享。通过标签的层级结构和业务ID的组合，实现了灵活的策略组织方式。

```mermaid
flowchart TD
A[策略标签] --> B[全局标签]
A --> C[业务标签]
B --> B1[/系统/]
B --> B2[/网络/]
B --> B3[/数据库/]
B --> B4[/应用/]
C --> C1[/业务A/]
C --> C2[/业务B/]
C --> C3[/业务C/]
B1 --> B11[/系统/主机/]
B1 --> B12[/系统/进程/]
B1 --> B13[/系统/磁盘/]
C1 --> C11[/业务A/订单/]
C1 --> C12[/业务A/支付/]
C1 --> C13[/业务A/库存/]
subgraph 跨业务共享
D[共享策略] --> E[标签: /系统/主机/]
F[业务A] --> D
G[业务B] --> D
H[业务C] --> D
end
```

**图示来源**
- [public.py](file://packages/monitor_web/strategies/resources/public.py)
- [strategy_label.py](file://packages/monitor_web/strategies/resources/strategy_label.py)

**本节来源**
- [public.py](file://packages/monitor_web/strategies/resources/public.py)
- [strategy_label.py](file://packages/monitor_web/strategies/resources/strategy_label.py)

## 外键约束与级联操作
系统通过外键约束和级联操作确保数据的一致性和完整性。当删除策略时，相关的监控项、查询配置、算法等都会被级联删除。

```mermaid
classDiagram
class StrategyModel {
+int id
+on_delete : CASCADE
}
class ItemModel {
+int id
+int strategy_id
+on_delete : CASCADE
}
class QueryConfigModel {
+int id
+int item_id
+on_delete : CASCADE
}
class AlgorithmModel {
+int id
+int item_id
+on_delete : CASCADE
}
class DetectModel {
+int id
+int strategy_id
+on_delete : CASCADE
}
class RelationModel {
+int id
+int strategy_id
+on_delete : CASCADE
}
class StrategyLabel {
+int id
+int strategy_id
+on_delete : CASCADE
}
StrategyModel --> ItemModel : "1对多"
ItemModel --> QueryConfigModel : "1对多"
ItemModel --> AlgorithmModel : "1对多"
StrategyModel --> DetectModel : "1对多"
StrategyModel --> RelationModel : "1对多"
StrategyModel --> StrategyLabel : "1对多"
note right of StrategyModel
删除策略时，
所有关联的监控项、
查询配置、算法等
都会被级联删除
end note
```

**图示来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [test_base.py](file://bkmonitor/bkmonitor/strategy/tests/test_base.py)

**本节来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [test_base.py](file://bkmonitor/bkmonitor/strategy/tests/test_base.py)

## 实体关系图
综合以上分析，策略模型与其他核心实体的关系如下：

```mermaid
erDiagram
STRATEGY {
int id PK
string name
string scenario
boolean is_enabled
int bk_biz_id
datetime create_time
datetime update_time
}
ITEM {
int id PK
int strategy_id FK
string expression
string name
}
QUERY_CONFIG {
int id PK
int item_id FK
string data_source_label
string data_type_label
string metric_id
json config
}
ALGORITHM {
int id PK
int item_id FK
int level
string algorithm_type
json config
}
DETECT {
int id PK
int strategy_id FK
int level
json config
}
ACTION_RELATION {
int id PK
int strategy_id FK
int config_id
json user_groups
json signal
}
STRATEGY_LABEL {
int id PK
string label_name
int strategy_id FK
int bk_biz_id
}
USER_GROUP {
int id PK
string name
int bk_biz_id
json channels
string timezone
}
DUTY_RULE {
int id PK
int user_group_id FK
string name
json config
}
DUTY_ARRANGE {
int id PK
int duty_rule_id FK
json users
json backups
}
METRIC_MAPPING {
int id PK
string config_field
int bk_biz_id
json mapping_detail
json mapping_range
}
DEFAULT_STRATEGY_ACCESS {
int id PK
int bk_biz_id
string access_type
string version
}
STRATEGY ||--o{ ITEM : "包含"
ITEM ||--o{ QUERY_CONFIG : "包含"
ITEM ||--o{ ALGORITHM : "包含"
STRATEGY ||--o{ DETECT : "包含"
STRATEGY ||--o{ ACTION_RELATION : "关联"
STRATEGY ||--o{ STRATEGY_LABEL : "标记"
ACTION_RELATION }|--|| USER_GROUP : "通知"
USER_GROUP ||--o{ DUTY_RULE : "拥有"
DUTY_RULE ||--o{ DUTY_ARRANGE : "包含"
STRATEGY ||--o{ METRIC_MAPPING : "使用"
STRATEGY ||--o{ DEFAULT_STRATEGY_ACCESS : "基于"
```

**图示来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [test_base.py](file://bkmonitor/bkmonitor/strategy/tests/test_base.py)
- [v2.py](file://packages/monitor_web/strategies/resources/v2.py)

**本节来源**
- [strategy.py](file://bkmonitor/bkmonitor/models/strategy.py)
- [test_base.py](file://bkmonitor/bkmonitor/strategy/tests/test_base.py)
- [v2.py](file://packages/monitor_web/strategies/resources/v2.py)