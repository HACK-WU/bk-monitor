# 收敛处理

<cite>
**本文档引用的文件**   
- [processor.py](file://bkmonitor\alarm_backends\service\converge\processor.py)
- [tasks.py](file://bkmonitor\alarm_backends\service\converge\tasks.py)
- [converge_manger.py](file://bkmonitor\alarm_backends\service\converge\converge_manger.py)
- [converge_func.py](file://bkmonitor\alarm_backends\service\converge\converge_func.py)
- [dimension.py](file://bkmonitor\alarm_backends\service\converge\dimension.py)
</cite>

## 目录
1. [引言](#引言)
2. [核心组件](#核心组件)
3. [架构概览](#架构概览)
4. [详细组件分析](#详细组件分析)
5. [依赖分析](#依赖分析)
6. [性能考量](#性能考量)
7. [故障排除指南](#故障排除指南)
8. [结论](#结论)

## 引言
本文档全面描述了告警收敛处理流程，从接收到原始告警事件到生成收敛后告警的完整处理过程。深入解析了告警匹配、收敛规则评估、状态维护和结果生成等环节。详细说明了收敛处理器（ConvergenceProcessor）的核心算法逻辑，特别是如何处理并发告警事件和保证收敛状态的一致性。文档还涵盖了收敛任务的调度机制和执行周期，以及异常情况下的重试策略。提供了收敛处理过程中的关键日志分析方法，帮助运维人员诊断收敛问题，并包含性能优化建议。

## 核心组件
告警收敛处理流程的核心组件包括收敛处理器（ConvergeProcessor）、收敛管理器（ConvergeManager）、收敛功能（ConvergeFunc）和维度处理器（DimensionHandler）。这些组件协同工作，实现从原始告警到收敛后告警的完整转换过程。收敛处理器负责整体流程控制和状态管理，收敛管理器处理收敛规则评估和状态维护，收敛功能实现具体的收敛策略逻辑，维度处理器则负责告警匹配和条件评估。

**本节来源**
- [processor.py](file://bkmonitor\alarm_backends\service\converge\processor.py#L0-L199)
- [converge_manger.py](file://bkmonitor\alarm_backends\service\converge\converge_manger.py#L0-L199)

## 架构概览
告警收敛处理流程采用分层架构设计，各组件职责明确，协同完成收敛任务。整个流程始于告警事件的接收，经过收敛处理器的调度，由收敛管理器进行规则评估，最终通过收敛功能执行具体的收敛策略。

```mermaid
graph TD
A[原始告警事件] --> B[收敛处理器]
B --> C[收敛管理器]
C --> D[维度处理器]
D --> E[告警匹配]
C --> F[收敛规则评估]
F --> G[状态维护]
B --> H[收敛功能]
H --> I[具体收敛策略]
I --> J[收敛后告警]
K[任务调度] --> B
L[异常处理] --> B
M[日志记录] --> B
```

**图示来源**
- [processor.py](file://bkmonitor\alarm_backends\service\converge\processor.py#L0-L199)
- [converge_manger.py](file://bkmonitor\alarm_backends\service\converge\converge_manger.py#L0-L199)
- [converge_func.py](file://bkmonitor\alarm_backends\service\converge\converge_func.py#L0-L200)

## 详细组件分析

### 收敛处理器分析
收敛处理器（ConvergeProcessor）是告警收敛流程的核心控制器，负责协调整个收敛过程。它初始化收敛上下文，获取并发锁，执行收敛逻辑，并处理各种异常情况。

#### 类图
```mermaid
classDiagram
class ConvergeProcessor {
+str status
+str comment
+str instance_type
+ShieldManager shield_manager
+bool is_illegal
+dict converge_config
+int sleep_time
+int instance_id
+str dimension
+str lock_key
+bool need_unlock
+Model instance_model
+Model instance
+list alerts
+dict context
+lock() void
+unlock() void
+run_converge() str
+get_dimension(safe_length) str
+push_to_queue() void
+push_to_action_queue() void
+push_converge_queue() void
}
class ConvergeLockError {
+__init__(*args, **kwargs) void
}
ConvergeProcessor --> ConvergeLockError : "抛出"
ConvergeProcessor --> ShieldManager : "使用"
ConvergeProcessor --> ConvergeManager : "创建"
ConvergeProcessor --> ConvergeFunc : "调用"
```

**图示来源**
- [processor.py](file://bkmonitor\alarm_backends\service\converge\processor.py#L0-L199)

#### 处理流程
```mermaid
flowchart TD
Start([开始]) --> Init["初始化收敛处理器"]
Init --> CheckValid["检查收敛配置有效性"]
CheckValid --> Valid{"配置有效?"}
Valid --> |否| SetIllegal["标记为非法收敛"]
Valid --> |是| GetLock["获取并发锁"]
GetLock --> LockSuccess{"获取锁成功?"}
LockSuccess --> |否| PushConvergeQueue["推送到收敛队列"]
LockSuccess --> |是| RunConverge["执行收敛逻辑"]
RunConverge --> HandleResult["处理收敛结果"]
HandleResult --> UpdateStatus["更新实例状态"]
UpdateStatus --> PushQueue["推送到相应队列"]
PushQueue --> End([结束])
SetIllegal --> End
PushConvergeQueue --> End
```

**图示来源**
- [processor.py](file://bkmonitor\alarm_backends\service\converge\processor.py#L200-L400)

### 收敛管理器分析
收敛管理器（ConvergeManager）负责收敛规则的评估和状态维护。它处理收敛实例的创建、关联和终止，确保收敛状态的一致性。

#### 类图
```mermaid
classDiagram
class ConvergeManager {
+list alerts
+dict converge_config
+str instance_type
+Model instance
+str dimension
+bool is_created
+datetime start_time
+int end_timestamp
+list match_action_id_list
+Model converge_instance
+int start_timestamp
+bool biz_converge_existed
+do_converge() bool
+get_related_ids() list
+create_converge_instance(start_time) Model
+insert_converge_instance() void
+get_converge_instance(start_time) Model
+connect_converge(status) void
+end_converge_by_id(converge_id, conv_instance) void
}
class DimensionHandler {
+str dimension
+dict condition
+int strategy_id
+int start_timestamp
+int end_timestamp
+str instance_id
+str instance_type
+dict converged_condition
+get_by_condition() list
+calc_converge_results(keys_length, converge_results) list
+get_sub_converge_instances() tuple
+get_set_keys(key, values) list
}
ConvergeManager --> DimensionHandler : "使用"
ConvergeManager --> ConvergeInstance : "创建"
ConvergeManager --> ConvergeRelation : "管理"
```

**图示来源**
- [converge_manger.py](file://bkmonitor\alarm_backends\service\converge\converge_manger.py#L0-L199)

#### 收敛流程
```mermaid
sequenceDiagram
participant Processor as "收敛处理器"
participant Manager as "收敛管理器"
participant DB as "数据库"
participant Redis as "Redis"
Processor->>Manager : do_converge()
Manager->>Manager : 检查现有收敛实例
alt 存在收敛实例
Manager-->>Processor : 返回True
else 不存在收敛实例
Manager->>Manager : 获取匹配的告警ID列表
Manager->>Redis : get_by_condition()
Redis-->>Manager : 返回匹配ID列表
Manager->>Manager : 检查匹配数量是否达到阈值
alt 达到阈值
Manager->>Manager : 创建新收敛实例
Manager->>DB : insert_converge_instance()
DB-->>Manager : 返回收敛实例
Manager->>Manager : 推送二级收敛队列
Manager->>Processor : 返回True
else 未达到阈值
Manager-->>Processor : 返回False
end
end
```

**图示来源**
- [converge_manger.py](file://bkmonitor\alarm_backends\service\converge\converge_manger.py#L200-L400)

### 收敛功能分析
收敛功能（ConvergeFunc）实现了具体的收敛策略逻辑，如"成功后跳过"、"失败时审批"等。每个收敛策略对应一个具体的方法。

#### 类图
```mermaid
classDiagram
class ConvergeFunc {
+Model current_instance
+int instance_id
+list matched_related_ids
+Model converge_instance
+str instance_type
+bool is_new
+dict converge_config
+bool biz_converge_existed
+skip_when_success() str
+approve_when_failed() str
+skip_when_proceed() str
+wait_when_proceed() str
+defense() str
+skip_when_exceed() str
+relevance() bool
+trigger() str
+collect_alarm() str
+collect() str
+send_collect_action(is_delay) void
}
ConvergeFunc --> ActionInstance : "查询"
ConvergeFunc --> ConvergeInstance : "关联"
ConvergeFunc --> run_action : "调用"
```

**图示来源**
- [converge_func.py](file://bkmonitor\alarm_backends\service\converge\converge_func.py#L0-L200)

#### 策略流程
```mermaid
flowchart TD
Start([开始]) --> CheckType["检查实例类型"]
CheckType --> IsConverge{"是二级收敛?"}
IsConverge --> |是| LogNotSupported["记录不支持信息"]
IsConverge --> |否| QueryHistory["查询执行历史"]
QueryHistory --> HistoryExists{"存在历史记录?"}
HistoryExists --> |否| ReturnFalse["返回False"]
HistoryExists --> |是| CheckSuccess["检查是否成功"]
CheckSuccess --> Success{"成功?"}
Success --> |是| ReturnSkipped["返回SKIPPED"]
Success --> |否| CheckProceed["检查是否进行中"]
CheckProceed --> Proceed{"进行中?"}
Proceed --> |是| ReturnSleep["返回SLEEP"]
Proceed --> |否| ReturnFalse
ReturnSkipped --> End([结束])
ReturnSleep --> End
ReturnFalse --> End
LogNotSupported --> End
```

**图示来源**
- [converge_func.py](file://bkmonitor\alarm_backends\service\converge\converge_func.py#L200-L325)

### 维度处理器分析
维度处理器（DimensionHandler）负责告警匹配和条件评估，通过Redis存储和查询机制实现高效的告警匹配。

#### 类图
```mermaid
classDiagram
class DimensionHandler {
+str dimension
+dict condition
+int strategy_id
+int start_timestamp
+int end_timestamp
+str instance_id
+str instance_type
+dict converged_condition
+get_by_condition() list
+calc_converge_results(keys_length, converge_results) list
+get_sub_converge_instances() tuple
+get_set_keys(key, values) list
}
class DimensionCalculator {
+int DimensionExpireMinutes
+str QUEUE_KEY_TEMPLATE
+calc_sub_converge_dimension() dict
}
DimensionHandler --> FTA_CONVERGE_DIMENSION_KEY : "使用"
DimensionHandler --> FTA_SUB_CONVERGE_DIMENSION_KEY : "使用"
DimensionCalculator --> CONST_MINUTES : "引用"
```

**图示来源**
- [dimension.py](file://bkmonitor\alarm_backends\service\converge\dimension.py#L0-L200)

#### 匹配流程
```mermaid
sequenceDiagram
participant Manager as "收敛管理器"
participant Handler as "维度处理器"
participant Redis as "Redis"
Manager->>Handler : get_by_condition()
Handler->>Handler : 检查实例类型
alt 二级收敛
Handler->>Handler : get_sub_converge_instances()
Handler->>Redis : zrangebyscore()
Redis-->>Handler : 返回结果
else 普通收敛
Handler->>Handler : 创建Redis管道
Handler->>Redis : zrangebyscore() for each key
Redis-->>Handler : 返回多个结果集
Handler->>Handler : calc_converge_results()
end
Handler-->>Manager : 返回匹配ID列表
```

**图示来源**
- [dimension.py](file://bkmonitor\alarm_backends\service\converge\dimension.py#L200-L403)

## 依赖分析
告警收敛处理流程涉及多个组件和外部系统的依赖关系。核心依赖包括数据库、Redis缓存、Celery任务队列和各种API服务。

```mermaid
graph TD
A[收敛处理器] --> B[收敛管理器]
A --> C[收敛功能]
A --> D[维度处理器]
B --> E[数据库]
B --> F[Redis]
C --> G[动作实例]
C --> H[收敛实例]
C --> I[run_action任务]
D --> F[Redis]
A --> J[Celery任务队列]
J --> K[run_converge任务]
K --> A
A --> L[日志系统]
A --> M[监控指标]
```

**图示来源**
- [processor.py](file://bkmonitor\alarm_backends\service\converge\processor.py#L0-L774)
- [tasks.py](file://bkmonitor\alarm_backends\service\converge\tasks.py#L0-L116)
- [converge_manger.py](file://bkmonitor\alarm_backends\service\converge\converge_manger.py#L0-L612)

## 性能考量
告警收敛处理流程在高负载场景下需要特别关注性能优化。关键性能指标包括处理延迟、并发处理能力和资源利用率。

### 并发控制
收敛处理器通过Redis计数器实现并发控制，限制同一维度的并发收敛数量：
```python
parallel_converge_count = max(int(self.converge_count) // 2, 1)
if client.incr(self.lock_key) > parallel_converge_count:
    raise ConvergeLockError
```

### 批处理优化
维度处理器使用Redis管道批量查询，减少网络往返次数，提高查询效率：
```python
pipeline = FTA_CONVERGE_DIMENSION_KEY.client.pipeline()
for key, values in self.condition.items():
    set_keys = self.get_set_keys(key, values)
    for set_key in set_keys:
        pipeline.zrangebyscore(set_key, self.start_timestamp, self.end_timestamp, withscores=True)
pipeline_results = pipeline.execute()
```

### 重试策略
收敛任务采用指数退避重试机制，最多重试3次，每次间隔30秒：
```python
if retry_times < 3:
    task_id = run_converge.apply_async(
        (converge_config, instance_id, instance_type, converge_context, alerts, retry_times + 1),
        countdown=CONST_HALF_MINUTE,
    )
```

**本节来源**
- [processor.py](file://bkmonitor\alarm_backends\service\converge\processor.py#L343-L373)
- [dimension.py](file://bkmonitor\alarm_backends\service\converge\dimension.py#L0-L200)
- [tasks.py](file://bkmonitor\alarm_backends\service\converge\tasks.py#L0-L116)

## 故障排除指南
### 关键日志分析
收敛处理过程中的关键日志可以帮助运维人员诊断问题：

1. **并发锁获取失败**：
```
get parallel converge failed, current_parallel_converge_count is {count}, converge condition is {dimension}
```
表示同一维度的并发收敛数量超过限制，需要检查收敛配置或增加并发限制。

2. **收敛实例创建失败**：
```
create converge_instance by instance({id}) failed：{error}
```
表示创建收敛实例失败，可能是数据库问题或配置错误。

3. **二级收敛已存在**：
```
action({id}|{converge_id}) will be skipped because count of biz_converge_lock_key({key}) is bigger than {count}
```
表示业务维度的二级收敛已达到阈值，当前告警被跳过。

### 常见问题
1. **收敛不生效**：检查收敛配置是否启用，收敛条件是否正确，以及收敛数量阈值是否合理。
2. **处理延迟过高**：检查Redis和数据库性能，调整并发处理参数，优化收敛规则。
3. **重复收敛**：检查维度配置是否唯一，确保收敛维度能够准确区分不同的收敛场景。

**本节来源**
- [processor.py](file://bkmonitor\alarm_backends\service\converge\processor.py#L307-L343)
- [converge_manger.py](file://bkmonitor\alarm_backends\service\converge\converge_manger.py#L273-L305)
- [tasks.py](file://bkmonitor\alarm_backends\service\converge\tasks.py#L0-L116)

## 结论
告警收敛处理流程通过分层架构设计，实现了高效、可靠的告警收敛功能。收敛处理器作为核心控制器，协调收敛管理器、收敛功能和维度处理器等组件，完成从原始告警到收敛后告警的完整转换过程。通过Redis缓存和数据库的协同工作，实现了高效的告警匹配和状态维护。并发控制和重试机制确保了系统的稳定性和可靠性。在高负载场景下，可以通过调整并发度、优化查询性能和合理配置收敛规则来提升系统性能。