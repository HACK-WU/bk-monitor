# 动作模型

<cite>
**本文档引用的文件**
- [action.py](file://bkmonitor/bkmonitor/models/fta/action.py)
- [constants/action.py](file://bkmonitor/constants/action.py)
- [action/utils.py](file://bkmonitor/bkmonitor/action/utils.py)
- [documents/action.py](file://bkmonitor/bkmonitor/documents/action.py)
</cite>

## 目录
1. [引言](#引言)
2. [动作模型（ActionInstance）架构](#动作模型actioninstance架构)
3. [通知组（NoticeGroup）架构](#通知组noticegroup架构)
4. [动作类型常量与配置差异](#动作类型常量与配置差异)
5. [动作执行逻辑与工具函数](#动作执行逻辑与工具函数)
6. [动作与告警的关联关系](#动作与告警的关联关系)
7. [配置示例：从告警触发到执行Job任务](#配置示例从告警触发到执行job任务)
8. [结论](#结论)

## 引言

在蓝鲸监控平台中，动作模型（ActionInstance）和通知组（NoticeGroup）是实现自动化告警处理和通知分发的核心组件。动作模型负责定义和执行各种处理动作，如通知、执行脚本、创建工单等，而通知组则定义了通知的接收人列表和通知方式。本文档将详细解析这两个组件的架构，阐述其字段用途、状态流转、配置差异以及执行逻辑，并提供一个完整的配置示例。

## 动作模型（ActionInstance）架构

动作模型（ActionInstance）是蓝鲸监控平台中用于表示一个具体执行动作的实体。它记录了动作的配置、执行状态、执行次数等关键信息。该模型定义在 `bkmonitor/bkmonitor/models/fta/action.py` 文件中。

### 核心字段解析

- **action_config_id**: 该字段表示与当前动作实例关联的动作配置ID。它指向 `ActionConfig` 模型的一个实例，该实例包含了动作的具体执行参数，如作业平台的任务模板ID、标准运维的流程ID等。通过此ID，系统可以获取到执行该动作所需的全部配置信息。

- **status**: 该字段表示动作实例的当前执行状态。状态值来自 `constants/action.py` 文件中定义的 `ActionStatus` 枚举类。常见的状态包括 `received`（已收到）、`running`（执行中）、`success`（成功）和 `failure`（失败）。状态决定了动作的生命周期和后续处理逻辑。

- **execute_times**: 该字段记录了该动作实例已被执行的次数。对于需要周期性执行的动作（如轮询任务），此字段用于控制重试和轮询的次数。

- **begin_time**: 虽然在提供的代码片段中未直接找到 `begin_time` 字段，但 `create_time` 字段记录了动作实例的创建时间，通常可以视为动作的开始时间。`create_time` 是一个 `DateTimeField`，用于记录动作被创建的精确时间点。

### 动作执行状态流转

动作实例的状态流转是其生命周期的核心。根据 `constants/action.py` 中的 `ACTION_STATUS_CHOICES` 和 `ActionStatus` 类，状态流转如下：

1.  **等待执行 (Waiting)**: 当一个告警触发了动作规则后，系统会创建一个 `ActionInstance`，其初始状态为 `received`（已收到）。如果该动作需要经过审批（如异常防御），则状态会变为 `waiting`（等待审批）。
2.  **执行中 (Running)**: 审批通过或无需审批时，动作进入执行阶段，状态变为 `running`（执行中）。此时，系统会调用相应的插件（如作业平台、标准运维）来执行具体任务。
3.  **成功 (Success)**: 如果任务执行顺利完成，动作实例的状态将更新为 `success`（成功）。
4.  **失败 (Failure)**: 如果任务执行过程中出现错误（如网络超时、脚本执行失败），状态将变为 `failure`（失败）。失败的具体原因会记录在 `failure_type` 和 `ex_data` 字段中。
5.  **已收敛 (Skipped)**: 在某些情况下，如告警已被其他处理流程覆盖或达到收敛条件，动作可能会被跳过，状态为 `skipped`（已跳过）。

此状态流转确保了动作的执行过程是可追踪和可管理的。

**Section sources**
- [action.py](file://bkmonitor/bkmonitor/models/fta/action.py#L280-L800)
- [constants/action.py](file://bkmonitor/constants/action.py#L562-L641)

## 通知组（NoticeGroup）架构

通知组（NoticeGroup）在代码中主要通过 `UserGroup` 模型来实现，它定义了通知的接收人列表和通知方式。虽然具体的 `UserGroup` 模型代码未在搜索结果中直接提供，但其功能和配置可以通过相关代码推断。

### 通知方式定义

通知方式由 `constants/action.py` 文件中的 `NoticeWay` 类定义。支持的通知方式包括：
- `sms`: 短信
- `mail`: 邮件
- `weixin`: 微信
- `qy_weixin`: 企业微信
- `voice`: 电话
- `wxwork-bot`: 企业微信机器人
- `bkchat`: 蓝鲸信息流

这些通知方式通过 `NOTICE_WAY_MAPPING` 字典映射到中文描述，如 `"sms": "短信"`。

### 接收人列表

接收人列表存储在 `UserGroup` 模型中。一个通知组可以包含多个用户，这些用户可以分为“负责人”（`main`）和“关注人”（`follower`）。当触发通知时，系统会根据配置，向通知组内的所有成员或特定类型的成员发送通知。通知的接收人信息通常作为 `ActionConfig` 执行配置的一部分，通过 `user_groups` 字段进行关联。

**Section sources**
- [constants/action.py](file://bkmonitor/constants/action.py#L660-L715)

## 动作类型常量与配置差异

动作的类型和行为由 `constants/action.py` 文件中的常量类定义，特别是 `ActionPluginType` 类。

### 动作类型常量

`ActionPluginType` 枚举了所有支持的动作类型：
- `NOTICE`: 通知
- `WEBHOOK`: HTTP回调
- `JOB`: 作业平台
- `SOPS`: 标准运维
- `ITSM`: 流程服务
- `COMMON`: 通用插件

### 不同动作的配置差异

不同类型的动作，其 `execute_config` 的结构和内容有显著差异：
- **通知 (NOTICE)**: 配置主要包含通知模板（`template`）、通知方式（`notice_ways`）和通知组（`user_groups`）。配置中会定义在告警异常、恢复等不同信号下发送的标题和内容模板。
- **执行脚本 (JOB)**: 配置会包含作业平台的任务模板ID（`template_id`）和执行该模板所需的参数（`template_detail`），如脚本内容、执行账户、目标IP等。
- **创建工单 (ITSM)**: 配置会指定流程服务的单据模板ID和需要填充的单据字段。
- **HTTP回调 (WEBHOOK)**: 配置会包含目标URL、请求方法（GET/POST）、请求头（headers）和请求体（body）等信息。

这些差异通过 `ActionPlugin` 模型的 `config_schema` 字段来定义，该字段是一个JSON结构，描述了前端表单的布局和后端执行的参数格式。

**Section sources**
- [constants/action.py](file://bkmonitor/constants/action.py#L25-L46)
- [action.py](file://bkmonitor/bkmonitor/models/fta/action.py#L59-L154)

## 动作执行逻辑与工具函数

动作的执行逻辑主要在 `ActionInstance` 模型的方法中实现，而一些辅助性的工具函数则位于 `bkmonitor/bkmonitor/action/utils.py` 文件中。

### 动作执行逻辑

`ActionInstance` 类包含了动作执行的核心逻辑：
- `create_sub_actions`: 用于创建子任务。例如，一个通知动作可能需要为“负责人”和“关注人”分别创建子任务。
- `get_content`: 根据当前状态和上下文，渲染出最终的通知内容或执行结果描述。它会使用Jinja2模板引擎，结合 `content_template` 和上下文变量（如告警信息、策略信息）生成文本。
- `insert_alert_log`: 将动作的执行结果（成功、失败等）作为一条日志记录插入到 `AlertLog` 中，以便在告警详情页中展示。

### 工具函数

`utils.py` 文件提供了一系列用于数据查询和处理的工具函数：
- `get_action_config_strategy_dict`: 查询指定动作配置（`config_ids`）关联了哪些策略（`Strategy`），并返回一个统计字典。
- `get_action_config_rules`: 查询指定动作配置被哪些告警分派规则（`AlertAssignRule`）所引用。
- `get_strategy_user_group_dict`: 获取策略与通知组（`UserGroup`）之间的映射关系。
- `validate_time_range`: 校验时间范围字符串（如 "09:00--18:00"）的格式是否正确。

这些工具函数在后台服务中被广泛调用，以支持策略、动作和通知组之间的复杂关联查询。

**Section sources**
- [action.py](file://bkmonitor/bkmonitor/models/fta/action.py#L344-L639)
- [utils.py](file://bkmonitor/bkmonitor/action/utils.py#L1-L281)

## 动作与告警的关联关系

动作与告警之间存在着紧密的触发和关联关系。这种关系主要通过以下方式建立：
1.  **触发信号 (signal)**: `ActionInstance` 的 `signal` 字段（如 `abnormal`, `recovered`, `closed`）直接对应告警的生命周期事件。当一个告警的状态发生变化时，会触发相应信号的动作。
2.  **关联告警 (alerts)**: `ActionInstance` 的 `alerts` 字段是一个JSON字段，直接存储了与该动作实例关联的告警ID列表。这建立了动作与一个或多个告警之间的直接链接。
3.  **策略关联 (strategy_id)**: `ActionInstance` 通过 `strategy_id` 字段与一个具体的监控策略关联。策略中定义了何时触发动作，而动作实例则记录了该策略下告警触发后的处理过程。

这种设计使得每一个动作实例都可以追溯到其源头（哪个策略、哪个告警），实现了完整的事件链路追踪。

**Section sources**
- [action.py](file://bkmonitor/bkmonitor/models/fta/action.py#L285-L300)

## 配置示例：从告警触发到执行Job任务

以下是一个从告警触发到执行作业平台（Job）任务的完整动作链配置示例：

1.  **创建动作配置 (ActionConfig)**:
    - **名称**: "重启Web服务器"
    - **插件类型**: `JOB` (作业平台)
    - **执行配置 (execute_config)**:
        ```json
        {
          "template_id": "12345",
          "template_detail": {
            "script_content": "systemctl restart nginx",
            "account": "root",
            "ip_list": "{{target.host.bk_host_innerip}}"
          },
          "timeout": 300
        }
        ```
    这里使用了变量 `{{target.host.bk_host_innerip}}`，它会在执行时被替换为告警目标主机的内网IP。

2.  **在策略中关联动作**:
    在一个监控CPU使用率的策略中，添加一个动作规则：
    - **触发信号**: `abnormal` (告警触发时)
    - **选择动作**: 选择上一步创建的 "重启Web服务器" 配置。

3.  **告警触发与执行**:
    当某台服务器的CPU使用率超过阈值时，系统会：
    - 创建一个 `ActionInstance`，其 `action_config_id` 指向 "重启Web服务器" 的ID。
    - 状态 (`status`) 初始为 `received`。
    - 系统解析 `execute_config`，将 `ip_list` 中的变量替换为实际的IP地址。
    - 调用作业平台API，使用模板ID `12345` 和解析后的参数创建并执行任务。
    - 根据任务执行结果，更新 `ActionInstance` 的状态为 `running`，最终更新为 `success` 或 `failure`。

**Section sources**
- [action.py](file://bkmonitor/bkmonitor/models/fta/action.py#L258-L277)
- [constants/action.py](file://bkmonitor/constants/action.py#L25-L46)

## 结论

本文档详细解析了蓝鲸监控平台中的动作模型（ActionInstance）和通知组（NoticeGroup）的架构。我们探讨了 `ActionInstance` 的核心字段（如 `action_config_id`, `status`, `execute_times`）的用途和状态流转机制，阐述了 `NoticeGroup` 如何通过 `UserGroup` 模型定义通知方式和接收人。我们还分析了不同动作类型（通知、执行脚本、创建工单）的配置差异，并说明了动作执行的核心逻辑和相关工具函数。最后，通过一个具体的配置示例，展示了从告警触发到执行Job任务的完整流程。这些组件共同构成了一个强大、灵活的自动化运维处理框架。