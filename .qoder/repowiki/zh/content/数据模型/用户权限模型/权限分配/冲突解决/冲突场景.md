# 冲突场景

<cite>
**本文档中引用的文件**
- [permission.py](file://bkmonitor/bkmonitor/iam/permission.py)
- [action.py](file://bkmonitor/bkmonitor/iam/action.py)
- [drf.py](file://bkmonitor/bkmonitor/iam/drf.py)
- [resource.py](file://bkmonitor/bkmonitor/iam/resource.py)
</cite>

## 目录
1. [引言](#引言)
2. [权限冲突类型](#权限冲突类型)
3. [权限检查核心逻辑](#权限检查核心逻辑)
4. [权限冲突场景分析](#权限冲突场景分析)
5. [权限处理工具与方法](#权限处理工具与方法)
6. [测试与验证](#测试与验证)
7. [结论](#结论)

## 引言
本文档旨在全面描述监控系统中可能出现的权限冲突场景。通过分析系统中的权限管理模块，详细解析了允许与拒绝冲突、不同优先级冲突、时效性冲突等常见场景的具体表现和触发条件。文档深入探讨了每种冲突场景对系统安全性和功能可用性的影响，并提供了实际代码示例来展示不同冲突场景的产生过程。此外，还为开发者提供了识别和诊断权限冲突的工具和方法，以及冲突场景的测试用例和验证方法，确保系统能够正确识别各种冲突情况。

## 权限冲突类型
在监控系统中，权限冲突主要分为以下几种类型：

### 允许与拒绝冲突
当用户同时拥有对同一资源的允许和拒绝权限时，会发生允许与拒绝冲突。这种冲突通常出现在用户被授予多个角色或权限组的情况下，其中一个角色允许访问某个资源，而另一个角色拒绝访问同一资源。

### 不同优先级冲突
不同优先级冲突发生在用户被授予具有不同优先级的权限时。例如，一个高优先级的策略可能允许访问某个资源，而一个低优先级的策略可能拒绝访问同一资源。系统需要明确的规则来决定哪个策略优先。

### 时效性冲突
时效性冲突涉及权限的有效期。当用户的权限在不同时间点发生变化时，可能会出现冲突。例如，一个权限可能在某个时间段内有效，而在另一个时间段内无效。系统需要能够正确处理这些时间上的重叠和冲突。

## 权限检查核心逻辑
权限检查的核心逻辑主要由`permission.py`文件中的`Permission`类实现。该类负责校验用户是否有执行特定动作的权限。

### Permission类
`Permission`类是权限检查的核心，它封装了与权限中心的交互逻辑。以下是`Permission`类的主要方法：

- `__init__`: 初始化权限检查器，设置用户名和租户ID。
- `is_allowed`: 校验用户是否有执行特定动作的权限。
- `batch_is_allowed`: 批量校验用户对多个资源的多个操作是否有权限。
- `get_apply_url`: 生成权限申请URL，用于用户申请缺失的权限。
- `get_apply_data`: 生成权限申请数据，用于展示用户需要申请的权限。

### 动作定义
`action.py`文件中定义了系统中所有的权限动作。每个动作都有一个唯一的ID、名称、类型（查看或管理）、版本号以及相关的资源类型和依赖动作。例如，`VIEW_BUSINESS`动作表示用户可以查看业务，而`MANAGE_BUSINESS`动作表示用户可以管理业务。

### 资源定义
`resource.py`文件中定义了系统中所有的资源类型。每个资源类型都有一个唯一的ID、系统ID、名称、选择模式和相关的实例选择。例如，`Business`资源类型表示CMDB业务，`ApmApplication`资源类型表示APM应用。

## 权限冲突场景分析
### 允许与拒绝冲突示例
假设用户A被授予了`VIEW_BUSINESS`权限，但同时又被拒绝了`MANAGE_BUSINESS`权限。在这种情况下，用户A可以查看业务，但不能管理业务。如果系统没有正确处理这种冲突，可能会导致用户A既能查看也能管理业务，从而引发安全问题。

```python
class Permission:
    def is_allowed(self, action: ActionMeta | str, resources: list[Resource] = None, raise_exception: bool = False):
        if self.skip_check:
            return True

        resources = resources or []

        action = get_action_by_id(action)
        if not action.related_resource_types:
            resources = []

        request = self.make_request(action, resources)

        try:
            if action.is_read_action():
                result = self.iam_client.is_allowed_with_cache(request)
            else:
                result = self.iam_client.is_allowed(request)
        except AuthAPIError as e:
            logger.exception("[IAM AuthAPI Error]: %s", e)
            result = False

        if not result and raise_exception:
            actions, detail_resources = self.prepare_apply_for_saas(resources)
            if not actions:
                detail_resources = []
                for resource in resources:
                    resource_mata = get_resource_by_id(resource.type)
                    detail_resources.append(resource_mata.create_instance(resource.id))
                actions = [action]
            apply_data, apply_url = self.get_apply_data(actions, detail_resources)

            raise PermissionDeniedError(
                context={"action_name": action.name},
                data={"apply_url": apply_url},
                extra={"permission": apply_data},
            )

        return result
```

### 不同优先级冲突示例
假设用户B被授予了一个高优先级的`VIEW_BUSINESS`权限和一个低优先级的`MANAGE_BUSINESS`权限。在这种情况下，系统需要明确的规则来决定哪个权限优先。通常，高优先级的权限会覆盖低优先级的权限。

### 时效性冲突示例
假设用户C的`VIEW_BUSINESS`权限在2023年1月1日至2023年12月31日之间有效，而`MANAGE_BUSINESS`权限在2023年6月1日至2023年6月30日之间有效。在这种情况下，用户C在2023年6月1日至2023年6月30日之间既可以查看也可以管理业务，但在其他时间只能查看业务。

## 权限处理工具与方法
### IAMPermission类
`drf.py`文件中的`IAMPermission`类是Django REST Framework中权限处理的核心。它继承自`permissions.BasePermission`，并实现了`has_permission`和`has_object_permission`方法。

```python
class IAMPermission(permissions.BasePermission):
    def __init__(self, actions: list[ActionMeta], resources: list[Resource] = None):
        self.actions = actions
        self.resources = resources or []

    def has_permission(self, request, view):
        if not self.actions:
            return True

        client = Permission()
        for index, action in enumerate(self.actions):
            try:
                client.is_allowed(
                    action=action,
                    resources=self.resources,
                    raise_exception=True,
                )
            except PermissionDeniedError as e:
                if index == len(self.actions) - 1:
                    raise e
            else:
                return True
        return True

    def has_object_permission(self, request, view, obj):
        return self.has_permission(request, view)
```

### BusinessActionPermission类
`BusinessActionPermission`类是`IAMPermission`的子类，专门用于处理与业务相关的权限检查。它通过将资源设置为业务实例来简化权限检查。

```python
class BusinessActionPermission(IAMPermission):
    def __init__(self, actions: list[ActionMeta]):
        super().__init__(actions)

    def has_permission(self, request, view):
        if not request.biz_id:
            return True
        self.resources = [ResourceEnum.BUSINESS.create_instance(request.biz_id)]
        return super().has_permission(request, view)

    def has_object_permission(self, request, view, obj):
        bk_biz_id = None
        if hasattr(obj, "bk_biz_id"):
            bk_biz_id = obj.bk_biz_id
        if bk_biz_id:
            self.resources = [ResourceEnum.BUSINESS.create_instance(bk_biz_id)]
            return super().has_object_permission(request, view, obj)
        return self.has_permission(request, view)
```

### ViewBusinessPermission类
`ViewBusinessPermission`类是`BusinessActionPermission`的子类，专门用于检查用户是否有查看业务的权限。

```python
class ViewBusinessPermission(BusinessActionPermission):
    def __init__(self):
        super().__init__([ActionEnum.VIEW_BUSINESS])
```

## 测试与验证
为了确保系统能够正确处理各种权限冲突场景，需要编写相应的测试用例。以下是一些可能的测试用例：

### 允许与拒绝冲突测试
- **测试目标**: 验证系统能否正确处理允许与拒绝冲突。
- **测试步骤**:
  1. 授予用户A`VIEW_BUSINESS`权限。
  2. 拒绝用户A`MANAGE_BUSINESS`权限。
  3. 尝试让用户A访问业务管理功能。
- **预期结果**: 用户A无法访问业务管理功能。

### 不同优先级冲突测试
- **测试目标**: 验证系统能否正确处理不同优先级的权限冲突。
- **测试步骤**:
  1. 授予用户B高优先级的`VIEW_BUSINESS`权限。
  2. 授予用户B低优先级的`MANAGE_BUSINESS`权限。
  3. 尝试让用户B访问业务管理功能。
- **预期结果**: 用户B可以访问业务管理功能。

### 时效性冲突测试
- **测试目标**: 验证系统能否正确处理时效性冲突。
- **测试步骤**:
  1. 授予用户C`VIEW_BUSINESS`权限，有效期为2023年1月1日至2023年12月31日。
  2. 授予用户C`MANAGE_BUSINESS`权限，有效期为2023年6月1日至2023年6月30日。
  3. 在2023年6月15日尝试让用户C访问业务管理功能。
- **预期结果**: 用户C可以访问业务管理功能。

## 结论
本文档详细描述了监控系统中可能出现的权限冲突场景，并提供了相应的解决方案和测试方法。通过深入分析权限检查的核心逻辑，我们能够更好地理解系统如何处理各种权限冲突，从而确保系统的安全性和功能可用性。开发者应根据本文档中的指导，编写相应的测试用例，以确保系统能够正确识别和处理各种权限冲突情况。

**本文档中引用的文件**
- [permission.py](file://bkmonitor/bkmonitor/iam/permission.py)
- [action.py](file://bkmonitor/bkmonitor/iam/action.py)
- [drf.py](file://bkmonitor/bkmonitor/iam/drf.py)
- [resource.py](file://bkmonitor/bkmonitor/iam/resource.py)