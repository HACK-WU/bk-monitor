# 用户管理

<cite>
**本文档引用的文件**   
- [bkmonitor\bk_dataview\models.py](file://bkmonitor\bk_dataview\models.py)
- [bkmonitor\bkmonitor\models\strategy.py](file://bkmonitor\bkmonitor\models\strategy.py)
- [bkmonitor\bkmonitor\action\serializers\strategy.py](file://bkmonitor\bkmonitor\action\serializers\strategy.py)
- [bkmonitor\bkmonitor\utils\cipher.py](file://bkmonitor\bkmonitor\utils\cipher.py)
- [bkmonitor\bkmonitor\utils\user.py](file://bkmonitor\bkmonitor\utils\user.py)
- [bkmonitor\bkmonitor\action\duty_manage.py](file://bkmonitor\bkmonitor\action\duty_manage.py)
- [bkmonitor\api\bk_login\default.py](file://bkmonitor\api\bk_login\default.py)
- [bkmonitor\bk_dataview\client.py](file://bkmonitor\bk_dataview\client.py)
- [bkmonitor\metadata\management\commands\switch_transfer_for_dataid.py](file://bkmonitor\metadata\management\commands\switch_transfer_for_dataid.py)
- [bkmonitor\bkmonitor\action\converter.py](file://bkmonitor\bkmonitor\action\converter.py)
</cite>

## 目录
1. [简介](#简介)
2. [用户实体实现](#用户实体实现)
3. [用户生命周期管理](#用户生命周期管理)
4. [用户认证机制](#用户认证机制)
5. [用户管理API使用示例](#用户管理api使用示例)
6. [用户与其他系统组件的关联关系](#用户与其他系统组件的关联关系)
7. [用户数据迁移和批量操作最佳实践](#用户数据迁移和批量操作最佳实践)

## 简介
本文档详细介绍了蓝鲸监控平台中的用户管理模块，重点阐述了用户实体的实现细节、用户生命周期管理流程、认证机制、API使用方法以及与其他系统组件的关联关系。文档旨在为开发者提供全面的用户管理功能指导，包括用户数据迁移和批量操作的最佳实践。

## 用户实体实现

### 用户模型字段定义
用户实体主要在 `bk_dataview/models.py` 文件中定义，其核心模型为 `User` 类。该模型定义了用户的各种属性及其数据类型和约束条件。

```python
class User(models.Model):
    """
    用户表
    """

    id = models.BigAutoField(primary_key=True)
    version = models.IntegerField(default=0)
    login = models.CharField(unique=True, max_length=190)
    email = models.CharField(unique=True, max_length=190)
    name = models.CharField(max_length=255, blank=True, null=True, default="")
    password = models.CharField(max_length=255, blank=True, null=True)
    salt = models.CharField(max_length=50, blank=True, null=True)
    rands = models.CharField(max_length=50, blank=True, null=True)
    company = models.CharField(max_length=255, blank=True, null=True, default="")
    org_id = models.BigIntegerField(default=1)
    is_admin = models.BooleanField(default=False)
    email_verified = models.BooleanField(blank=True, null=True, default=False)
    theme = models.CharField(max_length=255, blank=True, null=True)
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)
    help_flags1 = models.BigIntegerField(default=0)
    last_seen_at = models.DateTimeField(blank=True, null=True)
    is_disabled = models.BooleanField(default=False)
    is_service_account = models.BooleanField(default=False)

    class Meta:
        managed = False
        app_label = APP_LABEL
        db_table = "user"
        indexes = [models.Index(fields=["login", "email"])]
```

#### 字段说明
- **id**: 主键，自增的 `BigAutoField`。
- **version**: 版本号，`IntegerField`，默认值为 0。
- **login**: 登录名，`CharField`，唯一且最大长度为 190。
- **email**: 邮箱，`CharField`，唯一且最大长度为 190。
- **name**: 姓名，`CharField`，最大长度为 255，可为空。
- **password**: 密码，`CharField`，最大长度为 255，可为空。
- **salt**: 盐值，用于密码加密，`CharField`，最大长度为 50，可为空。
- **rands**: 随机字符串，`CharField`，最大长度为 50，可为空。
- **company**: 公司名称，`CharField`，最大长度为 255，可为空，默认为空字符串。
- **org_id**: 组织ID，`BigIntegerField`，默认值为 1。
- **is_admin**: 是否为管理员，`BooleanField`，默认值为 False。
- **email_verified**: 邮箱是否已验证，`BooleanField`，可为空，默认值为 False。
- **theme**: 主题，`CharField`，最大长度为 255，可为空。
- **created**: 创建时间，`DateTimeField`，自动添加。
- **updated**: 更新时间，`DateTimeField`，自动更新。
- **help_flags1**: 帮助标志，`BigIntegerField`，默认值为 0。
- **last_seen_at**: 最后登录时间，`DateTimeField`，可为空。
- **is_disabled**: 是否被禁用，`BooleanField`，默认值为 False。
- **is_service_account**: 是否为服务账户，`BooleanField`，默认值为 False。

**Section sources**
- [bkmonitor\bk_dataview\models.py](file://bkmonitor\bk_dataview\models.py#L15-L44)

## 用户生命周期管理

### 用户创建
用户创建流程通常通过调用 `bk_dataview/client.py` 中的 `create_user` 函数来实现。该函数向 Grafana API 发送 POST 请求，创建新用户。

```python
def create_user(username: str):
    url = f"{API_HOST}/api/admin/users/"
    password = get_random_string(12)
    data = {"name": username, "email": "", "login": username, "password": password}
    resp = rpool.post(url, json=data, auth=grafana_settings.ADMIN, hooks={"response": requests_curl_log})
    return resp
```

### 用户激活
用户激活通常在用户首次登录或通过邮箱验证后完成。系统会检查 `email_verified` 字段，并根据需要更新用户状态。

### 用户禁用
用户禁用通过将 `is_disabled` 字段设置为 `True` 来实现。这会阻止用户登录系统。

### 用户删除
用户删除通常通过调用 Grafana API 的删除用户接口来完成。系统会从数据库中移除用户记录。

**Section sources**
- [bkmonitor\bk_dataview\client.py](file://bkmonitor\bk_dataview\client.py#L28-L34)

## 用户认证机制

### 密码加密存储
用户密码的加密存储在 `bkmonitor/utils/cipher.py` 文件中实现。系统使用 AES 加密算法对密码进行加密。

```python
class AESCipher(object):
    def __init__(self, key, iv=None):
        self.bs = 16
        self.iv = iv
        self.key = hashlib.sha256(key.encode("utf-8")).digest()

    def encrypt(self, raw):
        if isinstance(raw, str):
            raw = raw.encode("utf-8")
        raw = self._pad(raw)
        iv = new().read(AES.block_size) if not self.iv else self.iv
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        result = base64.b64encode(iv + cipher.encrypt(raw))
        return result

    def decrypt(self, enc):
        if isinstance(enc, str):
            enc = enc.encode("utf-8")
        enc = base64.b64decode(enc)
        iv = enc[: AES.block_size] if not self.iv else self.iv
        cipher = AES.new(self.key, AES.MODE_CBC, iv)

        if not self.iv:
            return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode("utf-8")
        else:
            return self._unpad(cipher.decrypt(enc[len(iv):])).decode("utf-8")

    def _pad(self, s):
        return s + bytes((self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs), encoding="utf-8")

    @staticmethod
    def _unpad(s):
        return s[: -ord(s[len(s) - 1:])]
```

### 多因素认证支持
文档中未明确提及多因素认证的具体实现，但系统可能通过集成外部认证服务（如 `bk_login`）来支持多因素认证。

**Section sources**
- [bkmonitor\bkmonitor\utils\cipher.py](file://bkmonitor\bkmonitor\utils\cipher.py#L0-L164)

## 用户管理API使用示例

### 查询用户列表
通过调用 `api/bk_login/default.py` 中的 `GetAllUserResource` 类，可以查询用户列表。

```python
class GetAllUserResource(BkUserApiResource):
    """
    查询用户列表
    """

    action = "/list_users/"
    method = "GET"
    cache_type = CacheType.USER

    def perform_request(self, params):
        if self.use_apigw():
            return {"count": 0, "results": []}
        return super().perform_request(params)
```

### 创建用户
通过调用 `bk_dataview/client.py` 中的 `create_user` 函数，可以创建新用户。

```python
def create_user(username: str):
    url = f"{API_HOST}/api/admin/users/"
    password = get_random_string(12)
    data = {"name": username, "email": "", "login": username, "password": password}
    resp = rpool.post(url, json=data, auth=grafana_settings.ADMIN, hooks={"response": requests_curl_log})
    return resp
```

**Section sources**
- [bkmonitor\api\bk_login\default.py](file://bkmonitor\api\bk_login\default.py#L74-L113)
- [bkmonitor\bk_dataview\client.py](file://bkmonitor\bk_dataview\client.py#L28-L34)

## 用户与其他系统组件的关联关系

### 用户组
用户组在 `bkmonitor/models/strategy.py` 文件中定义，其核心模型为 `UserGroup` 类。用户组用于管理用户的权限和通知设置。

```python
class UserGroup(AbstractRecordModel):
    """
    告警处理组
    """

    name = models.CharField(max_length=128, verbose_name="用户组名称")
    bk_biz_id = models.IntegerField(verbose_name="业务ID", default=0, blank=True, db_index=True)
    timezone = models.CharField(verbose_name="时区", default="Asia/Shanghai", max_length=32)
    desc = models.TextField(verbose_name="说明/备注")
    source = models.CharField(verbose_name="来源系统", default=get_source_app_code, max_length=32)
    need_duty = models.BooleanField(verbose_name="是否需要轮值", default=False)
    channels = models.JSONField("告警通知渠道配置", default=list)
    mention_list = models.JSONField("告警提醒人", default=list)
    mention_type = models.IntegerField("提醒类型", default=0)
    alert_notice = models.JSONField("告警通知配置", default=list)
    action_notice = models.JSONField("执行通知配置", default=list)
    duty_notice = models.JSONField("轮值通知配置", default=dict)
    webhook_action_id = models.IntegerField("回调套餐ID", default=0)
    duty_rules = models.JSONField("轮值规则", default=list)
    app = models.CharField("所属应用", max_length=128, default="", blank=True, null=True)
    path = models.CharField("资源路径", max_length=128, default="", blank=True, null=True)
    hash = models.CharField("原始配置摘要", max_length=64, default="", blank=True, null=True)
    snippet = models.TextField("配置片段", default="", blank=True, null=True)

    class Meta:
        verbose_name = "告警处理组配置"
        verbose_name_plural = "告警处理组配置"
        db_table = "user_group"
        index_together = (("bk_biz_id", "source"),)
        ordering = ("-update_time",)
```

### 权限分配
权限分配通过 `UserRole` 模型实现，该模型定义了用户与角色之间的关系。

```python
class UserRole(models.Model):
    id = models.BigAutoField(primary_key=True)
    org_id = models.BigIntegerField()
    user_id = models.BigIntegerField()
    role_id = models.BigIntegerField()
    created = models.DateTimeField(auto_now_add=True)

    class Meta:
        managed = False
        app_label = APP_LABEL
        db_table = "user_role"
        unique_together = (("org_id", "user_id", "role_id"),)
        indexes = [
            models.Index(fields=["org_id"]),
        ]
```

**Section sources**
- [bkmonitor\bkmonitor\models\strategy.py](file://bkmonitor\bkmonitor\models\strategy.py#L460-L659)
- [bkmonitor\bk_dataview\models.py](file://bkmonitor\bk_dataview\models.py#L47-L60)

## 用户数据迁移和批量操作最佳实践

### 数据迁移
数据迁移通常通过 Django 的管理命令来实现。例如，`metadata/management/commands/switch_transfer_for_dataid.py` 文件中的命令用于切换数据源的传输集群。

```python
class Command(BaseCommand):
    def add_arguments(self, parser):
        parser.add_argument("transfer_cluster_id", type=str, help="target transfer cluster id")
        parser.add_argument("--data_id", type=int, nargs="*", help="data_id to switch")
        parser.add_argument("--bk_data_ids", type=str, help="data_ids, split by comma")
        parser.add_argument("--source_system", type=str, help="data_id for source system to switch")

    def handle(self, transfer_cluster_id, *args, **options):
        data_ids = options.get("data_id")
        bk_data_ids = options.get("bk_data_ids")
        source_system = options.get("source_system")

        if not (data_ids or bk_data_ids or source_system):
            raise CommandError("one of --data_id, --source_system or --bk_data_ids option must be given")

        queryset = DataSource.objects.all()
        if data_ids:
            queryset = queryset.filter(bk_data_id__in=data_ids)
        if source_system:
            queryset = queryset.filter(source_system=source_system)
        if bk_data_ids:
            filter_data_id_list = [int(data_id) for data_id in bk_data_ids.split(",")]
            queryset = queryset.filter(bk_data_id__in=filter_data_id_list)

        self.stdout.write(
            self.style.SUCCESS("[switch_transfer_for_dataid] START. Total count: {}".format(queryset.count()))
        )

        for datasource in queryset:
            # 执行数据迁移操作
            pass
```

### 批量操作
批量操作通过 `bulk_create` 和 `bulk_insert_ignore` 方法来实现，以提高性能。

```python
class BulkCreateIgnoreManager(ModelManager):
    def bulk_insert_ignore(self, create_fields, values):
        cursor = connections[settings.BACKEND_DATABASE_NAME].cursor()
        values_sql = "({})".format(",".join([" %s " for i in range(len(create_fields))]))
        sql = "INSERT IGNORE INTO {} ({}) VALUES {}".format(
            self.model._meta.db_table, ",".join(create_fields), values_sql
        )
        result = False
        try:
            cursor.executemany(sql, values)
            result = True
        except Exception as e:
            logger.exception(e)
        return result
```

**Section sources**
- [bkmonitor\metadata\management\commands\switch_transfer_for_dataid.py](file://bkmonitor\metadata\management\commands\switch_transfer_for_dataid.py#L25-L53)
- [bkmonitor\bkmonitor\models\fta\action.py](file://bkmonitor\bkmonitor\models\fta\action.py#L751-L788)