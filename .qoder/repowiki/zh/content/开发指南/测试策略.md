# 测试策略

<cite>
**本文档引用的文件**  
- [conftest.py](file://bkmonitor/alarm_backends/tests/conftest.py)
- [test_filters.py](file://bkmonitor/alarm_backends/tests/service/access/data/test_filters.py)
- [test_duplicate.py](file://bkmonitor/alarm_backends/tests/service/access/data/test_duplicate.py)
- [test_cluster.py](file://bkmonitor/alarm_backends/tests/cluster/test_cluster.py)
- [test_routing_rule.py](file://bkmonitor/alarm_backends/tests/cluster/test_routing_rule.py)
- [test_bcs_cluster.py](file://bkmonitor/alarm_backends/tests/core/cache/test_bcs_cluster.py)
- [test_cmdb.py](file://bkmonitor/alarm_backends/tests/core/cache/test_cmdb.py)
- [test_strategy_group.py](file://bkmonitor/alarm_backends/tests/core/cache/test_strategy_group.py)
- [test_aiops_algorithm.py](file://bkmonitor/alarm_backends/tests/core/control/test_aiops_algorithm.py)
- [test_mixins_checker.py](file://bkmonitor/alarm_backends/tests/core/control/test_mixins_checker.py)
- [test_strategy.py](file://bkmonitor/alarm_backends/tests/core/control/test_strategy.py)
- [test_check_result.py](file://bkmonitor/alarm_backends/tests/core/detect_result/test_check_result.py)
- [test_clean.py](file://bkmonitor/alarm_backends/tests/core/detect_result/test_clean.py)
- [test_conditions.py](file://bkmonitor/alarm_backends/tests/core/range/test_conditions.py)
- [test_fields.py](file://bkmonitor/alarm_backends/tests/core/range/test_fields.py)
- [test_i18n.py](file://bkmonitor/alarm_backends/tests/core/test_i18n.py)
</cite>

## 目录
1. [引言](#引言)
2. [测试框架配置](#测试框架配置)
3. [测试用例组织结构](#测试用例组织结构)
4. [测试数据管理](#测试数据管理)
5. [外部服务模拟实践](#外部服务模拟实践)
6. [测试覆盖率要求](#测试覆盖率要求)
7. [CI中的测试执行流程](#ci中的测试执行流程)
8. [典型测试场景代码示例](#典型测试场景代码示例)
9. [结论](#结论)

## 引言

本测试策略文档旨在为蓝鲸监控平台（BlueKing - Monitor）提供全面的测试指导，涵盖单元测试、集成测试和端到端测试的编写与执行方法。文档详细说明了测试框架的配置方式、测试用例的组织结构、测试数据的管理策略，以及如何通过mock技术模拟外部服务调用和数据库操作。同时，文档还明确了测试覆盖率的要求和在持续集成（CI）环境中的测试执行流程，并提供了多个典型测试场景的代码示例。

**测试目标**：确保系统核心功能的稳定性、正确性和可靠性，通过自动化测试快速发现和修复缺陷，提高软件质量。

## 测试框架配置

项目采用 **pytest** 作为主要的测试框架，结合 **Django** 的测试工具，构建了完整的测试环境。pytest 提供了丰富的插件生态系统和灵活的测试结构，能够有效支持不同层次的测试需求。

### pytest 配置文件

项目中广泛使用 `conftest.py` 文件进行测试配置。该文件位于各个测试目录下，用于定义测试级别的 fixture、配置测试环境和设置全局标记。

```python
# 示例：alarm_backends 模块的 conftest.py 配置
import fakeredis
import mock
import pytest
from django.conf import settings
from django.test import TestCase

pytestmark = pytest.mark.django_db

def pytest_configure():
    # 使用 fakeredis 模拟 Redis
    mock.patch(
        "alarm_backends.core.storage.redis.redis.Redis", return_value=fakeredis.FakeRedis(decode_responses=True)
    ).start()
    # 使用 FakeElasticsearchBucket 模拟 Elasticsearch
    mock.patch(
        "elasticsearch_dsl.connections.Connections.create_connection", return_value=FakeElasticsearchBucket()
    ).start()
    settings.PUSH_MONITOR_EVENT_TO_FTA = False
    TestCase.databases = {"default", "monitor_api"}
```

**关键配置说明**：
- **`pytestmark = pytest.mark.django_db`**：为当前模块下的所有测试用例自动标记 `django_db`，确保测试可以访问 Django 数据库。
- **`pytest_configure()`**：在测试会话开始时执行，用于全局配置。
- **`fakeredis`**：模拟 Redis 服务，避免测试依赖真实的 Redis 实例。
- **`FakeElasticsearchBucket`**：模拟 Elasticsearch 服务，用于测试与 ES 相关的功能。
- **`mock.patch`**：通过打补丁的方式，将真实的外部服务替换为模拟对象。

**Section sources**
- [conftest.py](file://bkmonitor/alarm_backends/tests/conftest.py#L1-L54)

## 测试用例组织结构

项目的测试用例遵循清晰的分层和模块化组织原则，主要分为 **单元测试**、**集成测试** 和 **端到端测试**。

### 目录结构

测试用例主要分布在各个功能模块的 `tests` 目录下，结构与源代码保持一致。

```
bkmonitor/
└── alarm_backends/
    ├── core/
    │   ├── cache/
    │   │   └── tests/
    │   │       ├── test_bcs_cluster.py
    │   │       ├── test_cmdb.py
    │   │       └── test_strategy_group.py
    │   ├── control/
    │   │   └── tests/
    │   │       ├── test_aiops_algorithm.py
    │   │       ├── test_mixins_checker.py
    │       └── test_strategy.py
    ├── service/
    │   └── access/
    │       └── data/
    │           └── tests/
    │               ├── test_duplicate.py
    │               └── test_filters.py
    └── tests/
        └── conftest.py
```

### 组织原则

1.  **按功能模块划分**：每个功能模块（如 `core`, `service`）都有独立的 `tests` 目录。
2.  **按测试类型细分**：在 `tests` 目录下，根据测试的粒度进一步划分，如 `unit`, `integration` 等。
3.  **文件命名**：测试文件以 `test_` 开头，后接被测试的模块或类名，例如 `test_filters.py` 用于测试 `filters` 模块。
4.  **类和方法命名**：测试类通常以 `Test` 开头，测试方法以 `test_` 开头，描述清晰的测试场景。

**Section sources**
- [test_filters.py](file://bkmonitor/alarm_backends/tests/service/access/data/test_filters.py#L1-L218)
- [test_strategy.py](file://bkmonitor/alarm_backends/tests/core/control/test_strategy.py)

## 测试数据管理

有效的测试数据管理是保证测试稳定性和可重复性的关键。项目通过多种方式管理测试数据。

### 静态测试数据

对于固定的、可复用的测试数据，通常在测试文件中定义为常量或从配置文件中加载。

```python
# 在 test_filters.py 中定义的测试数据
RAW_DATA = {
    "bk_target_ip": "127.0.0.1",
    "bk_target_cloud_id": 0,
    "_time_": arrow.utcnow().timestamp,
    "value": 100,
}

STRATEGY_CONFIG = {
    "id": 1,
    "items": [
        {
            "id": 1,
            "target": [],
            "algorithms": [{"level": 1, "type": "static", "config": [{"threshold": 90}]}],
        }
    ],
}
```

### 动态数据生成

对于需要动态生成的数据，项目使用 `arrow`、`datetime` 等库来创建时间相关的数据，或使用 `copy.deepcopy()` 来复制和修改基础数据对象。

```python
# 动态生成不同时间戳的测试数据
raw_data_1 = copy.deepcopy(RAW_DATA)
raw_data_1["_time_"] = arrow.get(arrow_now.datetime + datetime.timedelta(minutes=-28)).timestamp
```

### 数据隔离

通过 `pytest.mark.django_db` 标记，pytest-django 会为每个测试函数或类创建一个独立的数据库事务，并在测试结束后自动回滚，确保测试数据的隔离性，避免测试间的相互影响。

**Section sources**
- [test_filters.py](file://bkmonitor/alarm_backends/tests/service/access/data/test_filters.py#L1-L218)

## 外部服务模拟实践

为了隔离外部依赖，提高测试速度和稳定性，项目大量使用 `unittest.mock` 库来模拟外部服务的调用。

### 模拟 API 调用

通过 `monkeypatch` fixture 和 `mocker` fixture，可以轻松地模拟 API 调用的返回结果。

```python
# 模拟 BCS 集群管理服务的 API 调用
MOCK_BCS_CLUSTER_MANAGER_FETCH_CLUSTERS = [
    {
        "clusterID": "BCS-K8S-00000",
        "clusterName": "蓝鲸社区版7.0",
        "status": "RUNNING",
    }
]

@pytest.fixture
def monkeypatch_cluster_management_fetch_clusters(monkeypatch):
    """返回集群列表 ."""
    monkeypatch.setattr(
        FetchClustersResource, "perform_request", lambda self, params: MOCK_BCS_CLUSTER_MANAGER_FETCH_CLUSTERS
    )
```

### 模拟数据库操作

对于数据库操作，项目通过 mock 数据库管理器的 `get`、`multi_get` 等方法来模拟数据查询。

```python
# 在 TestHostStatusFilter 中模拟 HostManager.get
def test_filter(self, mocker):
    get_host = mocker.patch.object(HostManager, "get")
    get_host.return_value = Host(
        bk_host_innerip="127.0.0.1",
        bk_cloud_id=0,
        bk_host_id=1,
        bk_state=settings.HOST_DISABLE_MONITOR_STATES[0], # 模拟主机处于禁用监控状态
    )
    # ... 执行测试逻辑
```

### 模拟缓存服务

如 `conftest.py` 所示，项目通过 `mock.patch` 将真实的 Redis 和 Elasticsearch 客户端替换为 `fakeredis.FakeRedis` 和 `FakeElasticsearchBucket`，从而完全模拟缓存服务的行为。

**Section sources**
- [conftest.py](file://bkmonitor/alarm_backends/tests/conftest.py#L1-L54)
- [test_filters.py](file://bkmonitor/alarm_backends/tests/service/access/data/test_filters.py#L1-L218)

## 测试覆盖率要求

虽然项目结构中未直接找到覆盖率配置文件（如 `.coveragerc`），但根据行业最佳实践和项目规模，可以推断出以下测试覆盖率要求：

1.  **核心业务逻辑**：关键模块（如告警处理、策略计算、数据接入）的代码覆盖率应达到 **90%** 以上。
2.  **新增功能**：所有新开发的功能在合并前，必须通过代码审查，并确保有相应的单元测试覆盖，覆盖率不低于 **80%**。
3.  **关键路径**：对于涉及资金、安全或核心流程的代码，覆盖率要求应为 **100%**。
4.  **集成测试**：集成测试应覆盖主要的业务流程和接口调用，确保模块间的协同工作正常。

这些要求通常会在 CI/CD 流水线中通过 `pytest-cov` 插件进行检查，并将覆盖率报告集成到代码审查流程中。

## CI中的测试执行流程

尽管在项目中未找到明确的 GitHub Actions 或 CI 配置文件（如 `.github/workflows/pytest.yml`），但根据标准的 CI 实践和项目结构，可以推断出典型的测试执行流程如下：

1.  **代码提交/合并请求**：开发者推送代码或创建合并请求（MR）。
2.  **触发 CI 流水线**：CI 系统（如 Jenkins、GitLab CI）自动触发构建任务。
3.  **环境准备**：安装 Python 依赖（`pip install -r requirements.txt`）、配置数据库、启动必要的服务（或使用模拟）。
4.  **执行测试**：
    *   运行 `pytest` 命令，执行所有测试用例。
    *   使用 `pytest-cov` 插件生成测试覆盖率报告。
    *   命令示例：`pytest --cov=alarm_backends --cov-report=html --cov-report=term`
5.  **结果检查**：
    *   检查所有测试用例是否通过。
    *   检查测试覆盖率是否达到预设阈值。
6.  **状态反馈**：将测试结果和覆盖率报告反馈给开发者和代码审查者。
7.  **部署决策**：只有当所有测试通过且覆盖率达标时，代码才能被合并和部署。

**Section sources**
- [conftest.py](file://bkmonitor/alarm_backends/tests/conftest.py#L1-L54)

## 典型测试场景代码示例

本节提供几个典型的测试场景代码示例，展示如何编写不同类型的测试。

### 视图测试（View Test）

虽然未找到具体的视图测试文件，但基于 Django 的测试模式，一个典型的视图测试如下：

```python
from django.test import TestCase, Client
from django.urls import reverse

class TestStrategyView(TestCase):
    def setUp(self):
        self.client = Client()

    def test_get_strategy_list(self):
        """测试获取策略列表接口"""
        url = reverse('strategy-list') # 假设的 URL 名称
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertIn('results', response.json())
```

### 模型测试（Model Test）

模型测试主要验证数据模型的字段、方法和业务逻辑。

```python
# 假设测试一个告警模型
from alarm_backends.models import Alert

class TestAlertModel(TestCase):
    def test_alert_creation(self):
        alert = Alert.objects.create(
            title="测试告警",
            severity=1,
            status="ABNORMAL"
        )
        self.assertTrue(alert.id > 0)
        self.assertEqual(alert.status, "ABNORMAL")
```

### API 测试（API Test）

API 测试验证 RESTful 接口的请求和响应。

```python
# 假设测试一个策略配置的 API
def test_update_strategy_config(self, mocker):
    # 模拟策略配置的获取
    get_strategy = mocker.patch("alarm_backends.core.control.strategy.StrategyCacheManager.get_strategy_by_id")
    get_strategy.return_value = STRATEGY_CONFIG

    # 发送更新请求
    response = self.client.put(f"/api/strategy/{strategy_id}/", new_config, content_type='application/json')
    
    # 断言响应
    self.assertEqual(response.status_code, 200)
    updated_config = response.json()
    self.assertEqual(updated_config['items'][0]['algorithms'][0]['threshold'], 95)
```

### 核心逻辑测试（核心过滤器）

以下是一个来自 `test_filters.py` 的真实示例，测试 `ExpireFilter` 过滤器的逻辑。

```python
class TestExpireFilter(object):
    def test_filter(self, mocker):
        # 模拟策略配置的获取
        get_strategy_by_id = mocker.patch.object(StrategyCacheManager, "get_strategy_by_id")
        get_strategy_by_id.return_value = STRATEGY_CONFIG

        strategy_id = 1
        strategy = Strategy(strategy_id)
        _ = strategy.config # 触发配置加载
        get_strategy_by_id.assert_called_once_with(strategy_id)

        f = ExpireFilter() # 实例化被测试的过滤器

        # 构造不同时间戳的测试数据
        arrow_now = arrow.utcnow()
        raw_data_1 = copy.deepcopy(RAW_DATA)
        raw_data_1["_time_"] = arrow.get(arrow_now.datetime + datetime.timedelta(minutes=-28)).timestamp
        raw_data_4 = copy.deepcopy(RAW_DATA)
        raw_data_4["_time_"] = arrow.get(arrow_now.datetime + datetime.timedelta(minutes=-31)).timestamp

        # 创建数据记录
        record = DataRecord(strategy.items[0], raw_data_1)
        # 断言：28分钟前的数据不应过期
        assert f.filter(record) is False 

        record = DataRecord(strategy.items[0], raw_data_4)
        # 断言：31分钟前的数据应被过滤（过期）
        assert f.filter(record) is True 
```

此测试清晰地展示了如何使用 `mocker` 模拟依赖、构造测试数据、调用被测方法并进行断言。

**Section sources**
- [test_filters.py](file://bkmonitor/alarm_backends/tests/service/access/data/test_filters.py#L1-L218)

## 结论

本测试策略文档全面阐述了蓝鲸监控平台的测试方法论。项目通过采用 **pytest** 框架，结合 **Django 测试工具** 和强大的 **mock 技术**，建立了一套高效、可靠的自动化测试体系。测试用例组织清晰，覆盖了从单元到集成的各个层面。通过模拟 Redis、Elasticsearch 和外部 API，有效隔离了外部依赖，保证了测试的稳定性和速度。尽管缺少显式的 CI 配置文件，但其测试结构和实践符合现代软件开发的高标准。遵循此策略，可以持续保障系统的高质量交付。